\section{FRI-based VM security level calculation}

This section calculates the security level for a FRI-based VM in \cref{sec:fri_security_level}.

\subsection{FRI parameters}

Global parameters used in the FRI analysis:
\begin{itemize}
    \item $m_J$ --- Johnson parameter.
    \item $r_{FRI}$ --- number of FRI rounds.
    \item Folding factors $\folds=[k_0,k_1,\ldots,k_{r_{FRI}-1}]$;
    \item $t$ --- number of queries.
    \item $\theta$.
    \item $\delta$.
    \item $\rho$ --- rate of the Reed-Solomon code.
    \item $l_t$ --- trace length.
    \item $L$ --- list size.
    \item $\bgriq$ --- grinding parameter for the query phase.
    \item $n$ --- witness size.
    \item $\bhash$ --- number of bits in the hash function output.
    \item $\bproof$ --- proof size in bits.
    \item $\sbtch$ --- batch size.
\end{itemize}

Notation specific to the Johnson bound:
\begin{itemize}
    \item
\end{itemize}


\subsection{Fixed constants}

We fix the following constants for the soundness calculator:
\begin{itemize}
    \item $m_{\mathrm{J}}=16$. Set in \begin{verbatim}fri.py/get_johnson_parameter_m()\end{verbatim}
    \end{itemize}

\subsection{Security level for a FRI-based VM}\label{sec:fri_security_level}

The security level is calculated in \begin{verbatim}zkvms/fri_based_vm.py/get_security_levels()\end{verbatim}.

It is done separately for two different regimes: UDR and JBR --- using the same procedure:
\begin{enumerate}
    \item Calculate the FRI round-by-round soundness errors $\efrirbrU,\efrirbrJ$ using the formula from \cref{sec:fri-rbr-udr} and \cref{sec:fri-rbr-jbr}.
    \item Obtain optimal $\delta_U,\delta_J$ parameters using the formula from \cref{sec:fri_optimal_distance_udr} and \cref{sec:fri_optimal_distance_jbr}.
    \item Obtain the list sizes $L_U,L_J$ for the respective  $\delta_U,\delta_J$.
    \item Obtain the DEEP-ALI soundness errors $\edeepU,\edeepJ$ using the formulas from Section \ref{sec:deep_ali_soundness}.
    \item Compute the total soundness errors as
     $$
    \epsilon_U = \min(\efrirbrU, \edeepU),\quad \epsilon_J = \min(\efrirbrJ, \edeepJ).
    $$
\end{enumerate}
Then the  full security level in bits is the maximum of the two regimes:
$$
\text{Security level} = \max(-\log_2 \epsilon_U, -\log_2 \epsilon_J).
$$

\subsubsection{RBR soundness in UDR}\label{sec:fri-rbr-udr}

\begin{verbatim}fri_based_vm.py/get_security_levels_for_regime()\end{verbatim}

\subsubsection{RBR soundness in JBR}\label{sec:fri-rbr-jbr}

\begin{verbatim}fri_based_vm.py/get_security_levels_for_regime()\end{verbatim}

\subsubsection{Optimal distance in UDR}\label{sec:fri_optimal_distance_udr}


\begin{verbatim}unique_decoding.py/get_max_delta()\end{verbatim}

\subsubsection{Optimal distance in JBR}\label{sec:fri_optimal_distance_jbr}
This uses the $\eta = \frac{\sqrt{\rho}}{32}$ as per \verb|johnson_bound.py/get_eta()|

\begin{verbatim}johnson_bound.py/get_max_delta()\end{verbatim}

\begin{equation}\label{eq:delta_jbr}
    \delta_J(\rho) =1-\sqrt{ \rho}  -\eta = 1-\sqrt{ \rho}  -\frac{\sqrt{\rho}}{32}
\end{equation}


\subsubsection{List sizes} \label{sec:fri_list_sizes}
\begin{verbatim}unique_decoding.py/get_max_list_size()\end{verbatim}

\begin{verbatim}johnson_bound.py/get_max_list_size()\end{verbatim}
Using \cref{sec:fri_optimal_distance_jbr} we have
$$
\ell(\rho ) = \frac{1}{2\eta\sqrt{\rho}} = \frac{16}{\rho}.
$$

\subsubsection{DEEP-ALI errors}\label{sec:fri-deep-ali}
\begin{verbatim}fri_based_vm.py/get_DEEP_ALI_errors()\end{verbatim}

\subsection{Soundness formula}

This is calculated in \begin{verbatim}fri.py/get_FRI_query_phase_error()\end{verbatim}.

Query phase error:
\begin{equation}
    \epsilon_{\mathrm{query}} = (1-\theta)^{t}\cdot 2^{-\bgriq}
\end{equation}
The query phase error without grinding is computed as per \cite{}\footnote{Code refers to (7) and Th2 of [Hab22]}

\subsection{Proof size}

This calculation is performed in \begin{verbatim}fri.py/get_FRI_proof_size_bits()\end{verbatim}.
The FRI proof contains two parts: Merkle roots, and one "openings" per query,
  where an "opening" is a Merkle path for each folding layer.
     For each layer we count the size that
     this layer contributes, which includes the root and all Merkle paths.

Initial round: one root and one path per query.
     We assume that for the initial functions, there is only one Merkle root, and
     each leaf $i$ for that root contains symbols $i$ for all initial functions.

    Folding rounds:
     we assume that "siblings" for the following layers are grouped together
     in one leaf. This is natural as they always need to be opened together.

The proof size is calculated as follows:
\begin{multline}
    \bproof =   \underbrace{ \bhash+ t\cdot MP(\frac{n}{\folds[0]},\sbtch,\log_2 |\FFF|,\bhash)}_{\text{Initial round}} + \\
    +\underbrace{\sum_{1\leq i \leq r_{FRI}-2} \left(\bhash+
     t\cdot MP(\frac{n}{\prod_{1\leq j \leq  i} \folds[j]},\sbtch, \log_2|\FFF|,\bhash)\right)}_{\text{Folding rounds but last }}+\\
    +\underbrace{ \left(\bhash+
     t\cdot MP(\frac{n}{\folds[r_{FRI}-1]\prod_{1\leq j \leq  r_{FRI}-1} \folds[j]},\sbtch,\log_2 |\FFF|,\bhash)\right)}_{\text{Last folding round }}
    \end{multline}
where $MP(n, s, q, b)$ is the Merkle path size
calculated as
\begin{equation}
    MP(n,s,q,b) =   \underbrace{sq}_{\text{leaf size}}+\underbrace{sq}_{\text{sibling}}+ \underbrace{\left\lceil \log_2 n \right \rceil \cdot b}_{\text{co-path}}
\end{equation}